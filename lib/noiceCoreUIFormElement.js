/*
    noiceCoreUIFormElement

    this defines noiceCoreUIElement descendant classes
    for form elements. These are the two I've got going

        * dropdown
        * input

    these are all the possible HTML form elements though
    and we might wanna look into these:
        <button>, <datalist>, <fieldset>, <input>,<keygen>, <label>,
        <legend>, <meter>, <optgroup>, <option>, <output>, <progress>,
        <select>, <textarea>

    a child of this class has this form in html:

    <div [auto-generated by noiceCoireUIElement]>
        <label for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label>
        <input id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'}></input>
    </div>

    the layout mode of the containing div controls how the label is arranged in relation to the input element
    (or select or whatever the target form element is). This is controlled by the labelLocation attribute (see
    constructor notes).

    this.formElementLabel gives a reference to the label element
    this.formElement gives a reference to the target form element (select, input, etc)

    this.value gets and sets the value of this.formDOMElement

    this.valueChangeCallback() - this is an external callback invoked with the old and new values
    the callback can throw to abort setting the value. If the callback wants to handle self-assignment
    (that is actually assigning the new value to this.value), the callback should return a value. Certain
    element types (for instance input) will have attributes controlling which DOM event triggers the
    this callback (for instance 'select', 'line return', 'lose focus' etc, etc)
*/
class noiceCoreUIFormElement extends noiceCoreUIElement {

/*
    constructor({
        label:                  (str) textContent of the <label>
        labelLocation:          (enum) top | left | embed
        valueChangeCallback:    function(newValue, oldValue)
        enable:                 (bool) false = disabled, default true
        defaultValue:           (str) the default value (defaults to this.label)
        defaultValueClass:      (str) add this.formElement to this class when it contains the defaultValue (default: ncufeDefaultSelection)
        labelClass:             (str) add this this.formElementLabel (default: ncufeLabel)
    })
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:               1,
        _className:             'noiceCoreUIFormElement',
        _enable:                true,
        _label:                 null,
        _labelLocation:         'left',
        _name:                  null,
        _value:                 null,
        _defaultValue:          null,
        _html:                  null,
        _hasFormElement:        false,
        _labelClass:            'ncufeLabel',
        _defaultValueClass:     'ncufeDefaultSelection',
        _captureValueOn:        'focusoutOrReturn',
        _captureValueListeners: {input:false, keydown:false, focusout:false, change:false},
        classList:              ['ncuFormElement']
    },defaults),callback);

    /*
        note: render() got called for us by super()
        so it exists in the documentFragment
        starting here
    */

    // setup default values (meta)
    if (! this.isNotNull('label')){ this.label = this._className; }
    if (! this.isNotNull('name')){ this.name = this.label; }

    // this is the last thing that gets done before returning
    this.setup();

} // end constructor


/*
    getters and setters. the lot of them
*/
get enable(){ return(this._enable); }
set enable(v){
    this._enable = (v === true);
    if (this.formElement instanceof Element){ this.formElement.disabled = (! this._enable); }
}
get label(){ return(this._label); }
set label(v){

    if (this.formElement instanceof Element){
        this.formElementLabel.textContent = v;
        if ((this.labelLocation == 'embed') && (this.value == this.label)){
            this._label = v;
            this.value = v;
        }
    }
    this._label = v;
}
get labelLocation(){ return(this._labelLocation); }
set labelLocation(v){

    switch(v){
        case 'left':
            if (this.DOMElement instanceof Element){
                this.formElementLabel.style.textAlign = 'right';
                this.DOMElement.style.display = 'grid';
                this.DOMElement.style.gridTemplateColumns = '1fr 1fr';
                this.formElementLabel.style.alignSelf = 'center';
                this.formElementLabel.style.visibility = 'visible';
                if (this.labelLocation == 'embed'){ this.embedLabel(false); }
            }
            break;
        case 'top':
            if (this.DOMElement instanceof Element){
                this.DOMElement.style.display = 'grid';
                this.DOMElement.style.gridTemplateColumns = '1fr';
                this.formElementLabel.style.textAlign = 'left';
                this.formElementLabel.style.visibility = 'visible';
                if (this.labelLocation == 'embed'){ this.embedLabel(false); }
            }
            break;
        case 'none':
            this.formElementLabel.style.visibility = 'collapse';
            if (this.labelLocation == 'embed'){ this.embedLabel(false); }
            break;
        case 'embed':
            /*
                if the child class supports label embedding (has a function called embedLabel)
                we'll pass it off to that, otherwise we're just gonna return without changing the mode
            */
            if (typeof this.embedLabel === 'function'){
                this.formElementLabel.style.visibility = 'collapse';

                /*
                    very sloppy but this is so setDefaultValueStyle()
                    can know what mode we're in when it gets called from
                    the value setter, when embedLabel replaces the null value
                    (if it does)
                */
                this._labelLocation = v;
                this.embedLabel(true);
            }else{
                return(false);
            }
            break;
        default:
            return(false);
    }
    this._labelLocation = v;
}
get labelClass(){ return(this._labelClass); }
set labelClass(v){
    if (this.formElementLabel instanceof Element){
        if (this.isNOtNull(this.labelClass)){
            this.formElementLabel.classList.remove(this.labelClass);
        }
        this.formElementLabel.classList.add(v);
    }
    this._labelClass = v;
}

get name(){ return(this._name); }
set name(v){
    this._name = v;
    if (this.formElement instanceof Element){ this.formElement.setAttribute('name',this.label); }
}
get value(){
    if (this.formElement instanceof Element){
        return(this.formElement.value);
    }else{
        return(this._value);
    }
}
set value(v){
    let vt = v;
    if (this.hasAttribute('valueChangeCallback') && (this.valueChangeCallback instanceof Function)){
        try {
            let tmp = this.valueChangeCallback(vt, this._value);
            if (this.isNotNull(tmp)){ vt = tmp; }
        }catch(e){
            throw(new noiceException({
                message:        `${this._className}/value setter (callback) threw an error: ${e.toString()}`,
                messageNumber:   420,
                thrownBy:       `${this._className}/value setter (callback)`
            }));
        }
    }
    this._value = vt;
    if ((this.formElement instanceof Element) && (this.formElement.value != v)){


        /*
            loose end 4/1/20 @ 1754
            regarding what's happening with the 'value' attribute on instantiation ...
            the problem seems to be that somehow the value we are passing
            in on args to the constructor is not in the resulting object?
            pointing again to some crap in the inheritance chain.

            kinda works ok anyhow, so leaving it for later
        */

        this.formElement.value = v;
    }
    this.toggleDefaultValueStyle();
}

get defaultValue(){ return(this._defaultValue); }
set defaultValue(v){
    this._defaultValue = v;
    this.toggleDefaultValueStyle();
}


/*
    child classes must implement html getter/setters
    such that the getters for formElement and formElementLabel
    will return correctly.

    --> that means child classes must define:

        this.formElementGUID
        this.formElementLabelGUID

    in their html setters! ya dig!
*/
get hasFormElement(){ return(this.formElement instanceof Element); }
get formElement(){
    if (this.DOMElement instanceof Element){
        return(this.DOMElement.querySelector(`#${this.formElementGUID}`));
    }else{
        return(null);
    }
}
get formElementLabel(){
    if (this.DOMElement instanceof Element){
        return(this.DOMElement.querySelector(`#${this.formElementLabelGUID}`));
    }else{
        return(null);
    }
}


/*
    toggleDefaultValueStyle();
*/
toggleDefaultValueStyle(){
    if (this.formElement instanceof Element){
        if ((this.defaultValue == this.value) || ((this.labelLocation == 'embed') && (this.value == this.label))){
            this.formElement.classList.add(this._defaultValueClass);
        }else{
            this.formElement.classList.remove(this._defaultValueClass);
        }
    }
} // end toggleDefaultValueStyle


/*
    captureValueOn
*/
get captureValueOn(){ return(this._captureValueOn); }
set captureValueOn(v){
    if (! (this.formElement instanceof Element)){ return(false); }

    /*
        alright so basically i've discovered that it's damn near impossible to
        reliably call removeEventListener(). no shit! see notes in embedLabel()

        so the best I can do is try to make sure I never set up the same listener
        more than once, and let the callback decide if it's supposed to fire or not

        otherwise we'd call this right here. but removeEventListener() is not working
        so if we did, we'd end up making the same listener over and over ...

        also I can't seem to make a listener with a function reference that gets both
        an event and a this that is the object. just at this point ...
        whatever. the mess I've got here seems to work anyhow ...
    */
    //this.resetCaptureHooks();
    let that = this;
    switch(v){
        case 'focusout':
            if (this._captureValueListeners.hasOwnProperty('focusout') && (! this._captureValueListeners['focusout'])){
                this.formElement.addEventListener('focusout', function(e){ that.captureValue(e); });
                this._captureValueListeners['focusout'] = true;
            }
            break;
        case 'return':
            if (this._captureValueListeners.hasOwnProperty('keydown') && (! this._captureValueListeners['keydown'])){
                this.formElement.addEventListener('keydown', function(e){ that.captureValue(e); });
                this._captureValueListeners['keydown'] = true;
            }
            break;
        case 'focusoutOrReturn':
            if (this._captureValueListeners.hasOwnProperty('focusout') && (! this._captureValueListeners['focusout'])){
                this.formElement.addEventListener('focusout', function(e){ that.captureValue(e); });
                this._captureValueListeners['focusout'] = true;
            }
            if (this._captureValueListeners.hasOwnProperty('keydown') && (! this._captureValueListeners['keydown'])){
                this.formElement.addEventListener('keydown', function(e){ if (e.keyCode == 13){ that.formElement.blur();} });
                this._captureValueListeners['keydown'] = true;
            }
            break;
        case 'keydown':
            if (this._captureValueListeners.hasOwnProperty('keydown') && (! this._captureValueListeners['keydown'])){
                this.formElement.addEventListener('keydown', function(e){ that.captureValue(e); });
                this._captureValueListeners['keydown'] = true;
            }
            break;
        case 'input':
            if (this._captureValueListeners.hasOwnProperty('input') && (! this._captureValueListeners['input'])){
                this.formElement.addEventListener('input', function(e){ that.captureValue(e); });
                this._captureValueListeners['input'] = true;
            }
            break;
        case 'change':
            if (this._captureValueListeners.hasOwnProperty('change') && (! this._captureValueListeners['change'])){
                this.formElement.addEventListener('change', function(e){ that.captureValue(e); });
                this._captureValueListeners['input'] = true;
            }
            break;
        default:
            return(false);
    }
    this._captureValueOn = v;

}

/*
    remove any eventHandlers applied to this.formElement
    inside the captureValueOn setter
    --> THIS DOES NOT WORK (though it really, really should) <--
    see notes in embedLabel() of noiceCoreUIFormElementInput below
    left here, because who knows, maybe some day it'll start working?
*/
resetCaptureHooks(){
    switch(this.captureValueOn){
        case 'focusout':
            this.formElement.removeEventListener('focusout', that.captureValue);
            this._captureValueListeners['focusout'] = false;
            break;
        case 'return':
            this.formElement.removeEventListener('keydown', that.captureValue);
            this._captureValueListeners['keydown'] = false;
            break;
        case 'focusoutOrReturn':
            this.formElement.removeEventListener('focusout', that.captureValue);
            this.formElement.removeEventListener('keydown', that.captureValue);
            this._captureValueListeners['focusout'] = false;
            this._captureValueListeners['keydown'] = false;
            break;
        case 'keydown':
            this.formElement.removeEventListener('keydown', that.captureValue);
            this._captureValueListeners['keydown'] = false;
            break;
        case 'input':
            this.formElement.removeEventListener('input', that.captureValue);
            this._captureValueListeners['input'] = false;
            break;
        case 'change':
            this.formElement.removeEventListener('change', that.captureValue);
            this._captureValueListeners['change'] = false;
            break;
        default:
            return(false);
    }
}



/*
    captureValue()
    this assigns the screen value (this.value) to
    the application value (this._value)
    invoking the valueChangeCallback
*/
captureValue(event){

    /*
        since it is apparently not really possible to remove eventListeners
        this function is gonna get called every time for every damn event
        pretty much. So all of the logic about if this thing should execute
        or not pretty much has got to live here

        might as well add the embedded label exit handler call here too
    */
    let cont = false;
    if ((((event.type == 'keydown') && (event.keyCode == 13)) || (event.type == 'focusout')) && ((this.captureValueOn == 'focusoutOrReturn') || (this.captureValueOn == 'return'))){
        cont = true;
    }else if (this.captureValueOn == event.type){
        cont = true;
    }

    if (cont){

        // this feels very punk rock to me right now. opinion subject to change.
        this.value = this.value;

        // if we've got an embedded label and they left it blank
        if ((this.labelLocation == 'embed') && (/^\s*$/.test(this.value))){
            this.value = this.label;
        }
    }
}



/*
    the last thing to execute on instantiation.
    this is good for setting defaults and stuff.
    if the caller needs to hang hooks n' such,
    renderCallback() is fine for that. This is
    for hard-coded-ey type stuff.
*/
setup(){

    /*
        explicitly set default values now that we're completely sure
        that everything has been rendered
    */

    this.enable         = this._enable;
    this.label          = this._label;
    this.labelLocation  = this._labelLocation;
    this.name           = this._name;
    this.value          = this.defaultValue;
    this.captureValueOn = this.captureValueOn;

    /*
        hang the value change hook Here   TO DO <---
    */
}

} // end noiceCoreUIFormElement




/*
    noiceCoreUInput
    a single line character input <input>
    NOTE this needs expansion -- this is the *text type* of input there are many more
*/
class noiceCoreUIFormElementInput extends noiceCoreUIFormElement {


/*
    constructor({
        [inherited properties from above, plus]
        captureValueOn:     focusout | return | focusoutOrReturn (default) | keypress | input
                            executes this.value = this.value (yeah really)
                            it takes the screen value (this.value) and applies
                            it to the application value (this._value), invoking
                            the valueChangeCallback. It does all of that when
                            this.formElement receives an event defined thusly:
                                focusout            -> DOM focusout event
                                return              -> on DOM keypress event checks for linereturn and fires
                                focusoutOrReturn    -> both of the above
                                keypress            -> go get it! one key at a time!
                                input               -> DOM input event
        values:           [array, of, values, for, typeahead, menu, feature],
    })
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUIInput',
        _hasEmbededLabelEventListener:      false,
        _values:                            [],
        _maxLength:                         null,
        _minLength:                         null,
        _readonly:                          false,
        _size:                              null,
        _spellcheck:                        false,
        _autocorrect:                       false,
        _required:                          false
    }, defaults), callback);
} // end constructor

// required
get required(){ return(this._required); }
set required(v){
    this._required = (v === true);
    this.formElement.setAttribute('required', this.required);
    if (! this.required){ this.formElement.removeAttribute('required'); }
}

// autocorrect
get autocorrect(){ return(this._autocorrect); }
set autocorrect(v){
    this._autocorrect = (v === true);
    this.formElement.setAttribute('autocorrect', this.autocorrect);
}

// spellcheck
get spellcheck(){ return(this._spellcheck); }
set spellcheck(v){
    this._spellcheck = (v === true);
    this.formElement.setAttribute('spellcheck', this.spellcheck);
}

// size
get size(){ return(this._size); }
set size(v){
    if (this.isNull(v)){
        this.formElement.removeAttribute('size');
    }else{
        this.formElement.setAttribute('size', v);
    }
    this._size = v;
}

// readonly
get readonly(){ return(this._readonly); }
set readonly(v){
    this._readonly = (v === true);
    this.formElement.setAttribute('readonly', this.readonly);
    if (! this.readonly){ this.formElement.removeAttribute('readonly'); }
}

/* maxLength, minLength */
get maxLength(){ return(this._maxLength); }
set maxLength(v){
    if (this.isNull(v)){
        this.formElement.removeAttribute('maxLength');
    }else{
        this.formElement.setAttribute('maxLength', v);
    }
    this._maxLength = v;
}
get minLength(){ return(this._minLength); }
set minLength(v){
    if (this.isNull(v)){
        this.formElement.removeAttribute('minLength');
    }else{
        this.formElement.setAttribute('minLength', v);
    }
    this._minLength = v;
}

/*
    values getter and setter
*/
get values(){ return(this._values); }
set values(v){
    this._values = v;
    if (this.hasOwnProperty('DOMElement')){ this.updateOptions(); }
}

/*
    options in this context is an array on this.values
    of typeahead menu options
*/
updateOptions(){
    let that = this;

    // if we're not setup yet don't bother ...
    if (! that.hasAttribute('formElementDataList')){ return(false); }

    // remove everything
    that.formElement.removeAttribute('list');
    while(that.formElementDataList.firstChild){ that.formElementDataList.removevChild(that.formElementDataList.firstChild); }

    // replace options
    that.values.forEach(function(v){
        let t = document.createElement('option');
        t.value = v;
        that.formElementDataList.append(t);
    });

    // attach datalist to formElement if we have some values
    if (that.values.length > 0){ that.formElement.setAttribute('list', that.formElementDataListGUID); }
}


/*
    setup()
*/
setup(){
    super.setup();
    this.formElementDataList = this.DOMElement.querySelector(`#${this.formElementDataListGUID}`);
    if (this.values.length > 0){ this.updateOptions(); }

    // initialize options with default values that need to be setup post-render
    ['minLength', 'maxLength', 'readonly', 'size', 'spellcheck', 'autocorrect', 'required'].forEach(function(att){
        this[att] = this[att];      // bitchin'
    }, this);
}



/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementDataListGUID')){ this.formElementDataListGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label>
        <input id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'} type="text"></input>
        <datalist id="${this.formElementDataListGUID}"></datalist>
    `);
}



/*
    handle embedding and disembedding the label (that's a word, right?)
*/
embedLabel(bool){

    /*
        tried a ton of stuff here to make removeEventListener work
        (see note below). MDN says this should work:
        https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
        in any case, it doesn't, so the function has to know when not to execute
    */
    let that = this;
    function embeddedLabelExitFunctionPointer(e){
        if ((that.value == that.label) && (that.labelLocation == 'embed')){ that.value = ''; }
    };
    let f = embeddedLabelExitFunctionPointer;
    let el = this.formElement;

    if (bool === true){

        // set the value/defaultValue
        if (this.isNull(this.value)){
            this.value = this.label;
        }

        // focusin handler will remove the defaultValue (label) and defaultValue class
        if (! this._hasEmbededLabelEventListener){
            el.addEventListener('focusin', f, true);
            this._hasEmbededLabelEventListener = true;
        }
    }else{

        /*
            NOTE 3/18/20 @ 1515
            removeEventListener simply is not going to work.
            period. I do not know why. According to documentation this should work
            and I have pulled that apart right down to the goddamn WC3 reccomendations.

            this. should. work.

            at this point, the best I can do with it is make the event listeners spawn only once
            and put hooks in the callbacks so they know when to not execute.

            not happy with it, but I guess it'll work ... sorta ...

        */
        el.removeEventListener('focusin', f, true);  // sure, lets call it but it ain't gonna work
        if (this.value == this.label){ this.value = ''; }
    }

}

} // end noiceCoreUIFormElementInput



/*
    noiceCoreUISelect    (noiceCoreUIFormElementSelect)
    it's a dropdown menu
*/
class noiceCoreUIFormElementSelect extends noiceCoreUIFormElement {

/*
    constructor({
        values:         <obj> || <array>,
                        list of values for the menu.
                        the list can be flat strings or objects of the format value:displayValue

        defaultValue    <value in this.values>
                        make it born with this value (unless the label is embedded)
    })
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUISelect',
        _values:                            [],
        captureValueOn:                     'input',
    }, defaults), callback);
} // end constructor


/*
    values getter and setter
*/
get values(){ return(this._values); }
set values(v){
    this._values = v;
    if (this.hasOwnProperty('DOMElement')){ this.updateOptions(); }
}

/*
    kill all of the options, then blow 'em back in from this.values'
*/
updateOptions(){

        let that = this;

        if (!(this.formElement instanceof Element)){  return(false); }

        // clear out the old ones
        let tmp = this.formElement.options.length;                       // <-- <select>.options is a live list -- lesson learned
        for (let i=0; i < tmp; i++ ){ this.formElement.remove(0); }
        this.formElement.querySelectorAll('optgroup').forEach(function(e){
            that.formElement.removeChild(e);
        });

        // helper function returns a DOM Element corresponding to an array entry on this.values
        function getDOMElements(data){
            let el;
            if (typeof(data) == 'object'){
                if (data instanceof Array){

                    // [value, text]{
                    el = document.createElement('option');
                    el.value = data[0];
                    if (this.isNotNull(data[1])){ el.text = data[1]; }
                    el.selected = (that.isNotNull(that.value) && (that.value == el.value || that.value == el.text));

                }else if (data instanceof Object){
                    if (data.hasOwnProperty('label') && that.isNotNull(data.label) && data.hasOwnProperty('values') && (data.values instanceof Array)){

                        // { label: <submenuTitle>, data = [str,array,obj]}
                        // <optgroup>
                        el = document.createElement('optgroup');
                        el.label = data.label;
                        data.values.forEach(function(r){
                            let t =  getDOMElements(r);
                            el.append(t);
                        });
                    }else{
                        // { <value>:<displayValue>}
                        el = document.createElement('option');
                        el.value    = Object.keys(data)[0];
                        el.text     = data[el.value];
                        el.selected = (that.isNotNull(that.value) && (that.value == el.value || that.value == el.text));
                    }
                }
            }else if (typeof(data) == 'string'){
                // value == text == data
                el = document.createElement('option');
                el.value = data;
                el.text = data;
                el.selected = (that.isNotNull(that.value) && (that.value == el.value || that.value == el.text));
            }
            el.disabled = false;
            return(el);
        }


        this.values.forEach(function(o){
            this.formElement.add(getDOMElements(o));
        }, this);


        return(true);
}

embedLabel(bool){

    /*
        note: embeded label mode really doesn't work that
        well with option groups
    */

    let that = this;
    if (bool === true){
        /*
            add the non-selectable label at index 0
        */
        if (! this.hasAttribute('_embeddedLabelOptionElement')){ this._embeddedLabelOptionElement = document.createElement('option'); }
        this._embeddedLabelOptionElement.disabled      = true;
        this._embeddedLabelOptionElement.value         = this.label;
        this._embeddedLabelOptionElement.text          = this.label;
        this._embeddedLabelOptionElement.selected      = true;
        // this._embeddedLabelOptionElement.classList.add(this.embeddedLabelClass);
        this.formElement.add(this._embeddedLabelOptionElement, 0);
        this.toggleDefaultValueStyle();

    }else{
        /*
            remove it
        */
        if (this.hasAttribute('_embeddedLabelOptionElement')){
            this.formElement.remove(0);
            delete(this._embeddedLabelOptionElement);
        }
    }
}


/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label>
        <select id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'}></select>
    `);
}

/*
    setup()
*/
setup(){
    super.setup();

    // setup the options
    this.updateOptions();

    // fire the initial selection
    this.value = this.value;
}


} // end noiceCoreUISelect




/*
    noiceCoreUIFormElementText

    * textarea (multi-line text entry)
      https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea

*/
class noiceCoreUIFormElementText extends noiceCoreUIFormElementInput {


/*
    constructor({
        autocapitalize:     none|sentences|words|characters
        cols:               <int>   (default 20)
        rows:               <int>
        wrap:               hard|soft|off (default soft)
    })
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUIText',
        _autocapitalize:                    null,
        _cols:                              20,
        _rows:                              1,
        _wrap:                              'soft',
        _resize:                            'none',
        captureValueOn:                     'focusout'
    }, defaults), callback);
} // end constructor

get resize(){ return(this._resize); }
set resize(v){
    this._resize = v;
    if (this.formElement instanceof Element){
        this.formElement.style.resize = this.resize;
    }
}

get cols(){ return(this._cols); }
set cols(v){
    this._cols = v;
    if (this.formElement instanceof Element){ this.formElement.setAttribute('cols', this.cols); }
}

get rows(){ return(this._rows); }
set rows(v){
    this._rows = v;
    if (this.formElement instanceof Element){ this.formElement.setAttribute('rows', this.rows); }
}

get autocapitalize(){ return(this._autocapitalize); }
set autocapitalize(v){
    this._autocapitalize = v;
    if (this.formElement instanceof Element){
        if (this.isNull(v)){
            this.formElement.removeAttribute('autocapitalize');
        }else{
            this.formElement.setAttribute('autocapitalize', this.autocapitalize);
        }
    }
}

get wrap(){ return(this._wrap); }
set wrap(v){
    this._wrap = v;
    if (this.formElement instanceof Element){
        if (this.isNull(v)){
            this.formElement.removeAttribute('wrap');
        }else{
            this.formElement.setAttribute('wrap', this.wrap);
        }
    }
}


/*
    setup()
*/
setup(){
    super.setup();

    // initialize options with default values that need to be setup post-render
    ['cols', 'rows', 'autocapitalize', 'wrap', 'resize'].forEach(function(att){
        this[att] = this[att];      // bitchin'
    }, this);
}


/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementDataListGUID')){ this.formElementDataListGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label>
        <textarea id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'}></textarea>
        <datalist id="${this.formElementDataListGUID}"></datalist>
    `);
}

} // end noiceCoreUIFormElementText




/*
    noiceCoreUIFormElementNumber

    * number (it's a remedy style integer with the arrows and everything!)
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date
*/
class noiceCoreUIFormElementNumber extends noiceCoreUIFormElementInput {


/*
    constructor({
        min:        <number>
        max:        <number>
        step:       <number> (increment) default: 'any'
                             note this can be used to control precision for floating point numbers
                             for instance set step=.001 to imply a precision of 3
    })

    NOTE: it looks like hiding/showing the number input spinner is a whole pain in the ass currently
          https://developer.mozilla.org/en-US/docs/Web/CSS/::-webkit-inner-spin-button
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUIText',
        _min:                               0,
        _max:                               1,
        _step:                              .01,
        captureValueOn:                     'focusoutOrReturn'
    }, defaults), callback);
} // end constructor

/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementDataListGUID')){ this.formElementDataListGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label>
        <input type="number" id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'}></input>
        <datalist id="${this.formElementDataListGUID}"></datalist>
    `);
}

/*
    getters n' setters
*/
get min(){ return(this._min); }
set min(v){
    this._min = v;
    if (this.formElement instanceof Element){
        if (this.isNull(v)){
            this.formElement.removeAttribute('min');
        }else{
            this.formElement.setAttribute('min', v);
        }
    }
}

get max(){ return(this._max); }
set max(v){
    this._max = v;
    if (this.formElement instanceof Element){
        if (this.isNull(v)){
            this.formElement.removeAttribute('max');
        }else{
            this.formElement.setAttribute('max', v);
        }
    }
}

get step(){ return(this._step); }
set step(v){
    this._step = v;
    if (this.formElement instanceof Element){
        if (this.isNull(v)){
            this.formElement.removeAttribute('step');
        }else{
            this.formElement.setAttribute('step', v);
        }
    }
}

/*
    setup()
*/
setup(){
    super.setup();

    // initialize options with default values that need to be setup post-render
    ['min', 'max', 'step'].forEach(function(att){ this[att] = this[att]; }, this);
}


} // end noiceCoreUIFormElementNumber




/*
    noiceCoreUIFormElementDate

    * date (date picker)
      https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date
*/
class noiceCoreUIFormElementDate extends noiceCoreUIFormElementNumber {


/*
    constructor({
        min:        <number>
        max:        <number>
        step:       <number> (increment) default: 'any'
                             note this can be used to control precision for floating point numbers
                             for instance set step=.001 to imply a precision of 3
    })

    NOTE: it looks like hiding/showing the number input spinner is a whole pain in the ass currently
          https://developer.mozilla.org/en-US/docs/Web/CSS/::-webkit-inner-spin-button
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUIFormElementDate',
        _min:                               '1970-01-01',
        _max:                               '2270-01-01',
        _step:                              1,
        captureValueOn:                     'focusoutOrReturn'
    }, defaults), callback);
} // end constructor

/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementDataListGUID')){ this.formElementDataListGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label>
        <input type="date" id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'}></input>
        <datalist id="${this.formElementDataListGUID}"></datalist>
    `);
}


}  // noiceCoreUIFormElementDate



/*
    noiceCoreUIFormElementCheckbox

    * checkbox
      https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox
*/
class noiceCoreUIFormElementCheckbox extends noiceCoreUIFormElement {

/*
    constructor({
        * checked   <bool>
    })
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUICheckbox',
        _required:                          false,
        _checked:                           false,
        _readonly:                          false
    }, defaults), callback);
} // end constructor

/*
    getters and setters
*/
get required(){ return(this._required); }
set required(v){
    this._required = (v === true);
    if (this.formElement instanceof Element){
        if (this._required){
            this.formElement.setAttribute('required', true);
        }else{
            this.formElement.removeAttribute('required');
        }
    }
}
get checked(){ return(this._checked); }
set checked(v){
    this._checked = (v === true);
    if (this.formElement instanceof Element){
        if (this._checked){
            this.formElement.setAttribute('checked', true);
        }else{
            this.formElement.removeAttribute('checked');
        }
    }
}
get readonly(){ return(this._readonly); }
set readonly(v){
    this._readonly = (v === true);
    if (this.formElement instanceof Element){
        if (this._readonly){
            this.formElement.setAttribute('readonly', true);
        }else{
            this.formElement.removeAttribute('readonly');
        }
    }
}

/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label>
        <input type="checkbox" id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'}></input>
    `);
}

/*
    setup
*/
setup(){
    super.setup();
    // initialize options with default values that need to be setup post-render
    ['required', 'checked', 'readonly', 'value'].forEach(function(att){ this[att] = this[att]; }, this);
}

} // end noiceCoreUIFormElementCheckbox




/*
    noiceCoreUIFormElementFile

        * file
          https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file
          https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications

      this is a file upload input
      I think this also has capability to capture an image as a file from built in cameras
      attributes:

            * value
              the pathname to the file selected (this may be extremely bogus)

            * files [FileList -- array like struct]
              list of File objects, this is how you get access to them
              https://developer.mozilla.org/en-US/docs/Web/API/File
*/
class noiceCoreUIFormElementFile extends noiceCoreUIFormElement {



/*
    constructor({
        accept:     <extensions or mime types> (default null)
        multiple:   <bool> accept multiple files or not
    })
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:           1,
        _className:         'noiceCoreUIFile',
        _accept:            null,
        _multiple:          false,
        _captureValueOn:    'change',
        _fileList:          []
    }, defaults), callback);

} // end constructor

// getters & setters
get accept(){ return(this._accept); }
set accept(v){
    this._accept = v;
    if (this.hasFormElement){
        this.formElement.setAttribute('accept', this.accept);
        if (this.isNull(v)){ this.formElement.deleteAttribute('accept'); }
    }
}
get multiple(){ return(this._multiple); }
set multiple(v){
    this._multiple = (v === true);
    if (this.hasFormElement){
        this.formElement.setAttribute('multiple', this.muktiple);
        if (this.isNull(v)){ this.formElement.deleteAttribute('multiple'); }
    }
}

/*
    override value getter
    we're returning the fileList
*/

set value(v){
    let vt = v;
    if (this.hasAttribute('valueChangeCallback') && (this.valueChangeCallback instanceof Function)){
        try {
            let tmp = this.valueChangeCallback(vt, this._value);
            if (this.isNotNull(tmp)){ vt = tmp; }
        }catch(e){
            throw(new noiceException({
                message:        `${this._className}/value setter (callback) threw an error: ${e.toString()}`,
                messageNumber:   420,
                thrownBy:       `${this._className}/value setter (callback)`
            }));
        }
    }
    this._value = vt;
}


/*
    captureValue(evt) override
    this should fire on 'change' (someone added or removed a file)
*/
captureValue(evt){

    // grab the fileList invoke the valueChangeCallback
    this.value = evt.target.files;
}


/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label>
        <input id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'} type="file"></input>
    `);
}


} // end noiceCoreUIFormElementFile
